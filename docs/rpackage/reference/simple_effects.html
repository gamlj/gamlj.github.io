<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Simple Effects on GAMLj results — simple_effects • GAMLj3</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Simple Effects on GAMLj results — simple_effects"><meta property="og:description" content="This is a convenience function to re-estimates a GAMLj model adding simple effect analysis. If no option is passed, extracts the 
simple effects tables already in the model results (if any). If new tests are defined, the simple effects tests tables 
are returned."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">GAMLj3</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">3.3.9</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/vignettes_gamlj_lm.html">Examples of gamlj_lm()</a>
    </li>
    <li>
      <a href="../articles/vignettes_gamlj_methods.html">Examples of GAMLj Methods</a>
    </li>
    <li>
      <a href="../articles/vignettes_plot.html">Plots in GAMLj</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Simple Effects on GAMLj results</h1>
    
    <div class="hidden name"><code>simple_effects.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This is a convenience function to re-estimates a GAMLj model adding simple effect analysis. If no option is passed, extracts the 
simple effects tables already in the model results (if any). If new tests are defined, the simple effects tests tables 
are returned.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">simple_effects</span><span class="op">(</span><span class="va">object</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for gamlj</span></span>
<span><span class="fu">simple_effects</span><span class="op">(</span><span class="va">object</span>, formula <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>object</dt>
<dd><p>a gamlj results object of the class `gamlj`</p></dd>


<dt>...</dt>
<dd><p>all options accepted by a gamlj model function. Relevant for new tests are 
`simple_x` (the simple effect variable), <code>`simple_mods`</code>, the moderator(s). Both are overriden by the formula option.</p></dd>


<dt>formula</dt>
<dd><p>a right hand side formula specifying the variables to test, of the form `~x:z`, `~x:z:w` or `~x*z`. 
The formula is not expanded, so the first variable is the simple effect variable, the second is the moderator, 
the third an optional additional moderator, an so on.
It has prevalence on other options defining a simple effects test via character options.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p>a list of tables of class `ResultsElement`</p>
    </div>
    <div id="author">
    <h2>Author</h2>
    <p>Marcello Gallucci</p>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">wicksell</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">wicksell</span><span class="op">$</span><span class="va">time</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">wicksell</span><span class="op">$</span><span class="va">time</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">wicksell</span><span class="op">$</span><span class="va">group</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">wicksell</span><span class="op">$</span><span class="va">group</span><span class="op">)</span> </span></span>
<span class="r-in"><span><span class="va">wicksell</span><span class="op">$</span><span class="va">subj</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">wicksell</span><span class="op">$</span><span class="va">subj</span><span class="op">)</span> </span></span>
<span class="r-in"><span><span class="va">gmod</span><span class="op">&lt;-</span><span class="fu">GAMLj3</span><span class="fu">::</span><span class="fu"><a href="gamlj_mixed.html">gamlj_mixed</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>   formula <span class="op">=</span> <span class="va">dv</span> <span class="op">~</span> <span class="fl">1</span> <span class="op">+</span><span class="va">group</span><span class="op">+</span> <span class="va">time</span><span class="op">:</span><span class="va">group</span><span class="op">+</span> <span class="va">time</span><span class="op">+</span><span class="op">(</span> <span class="fl">1</span> <span class="op">|</span> <span class="va">subj</span> <span class="op">)</span>,</span></span>
<span class="r-in"><span>   data <span class="op">=</span> <span class="va">wicksell</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: lmer   #### phase init  ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: lmer   #### phase run ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ______begin________</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> classes </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Runner Operator Scaffold R6 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> _____end_______</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: checking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: making options</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: running</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: trying optimizer bobyqa</span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>Setting class(x) to multiple strings ("lmerModLmerTest", "lmer", ...); result will no longer be an S4 object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> RUNNER: initial estimation done,  0.0382132530212402  secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> private$.estimator[[fun]]()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bc4b71d0</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> trying to get slot "optinfo" from an object (class "lmerModLmerTest") that is not an S4 object  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> `r2()` does not support models of class `lmerModLmerTest`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^r2(self$operator$model, self$operator)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0ba8cc910</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> object of type 'S4' is not subsettable </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^stats::anova(model, type = "3", ddf = df)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0b9c9c410</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> object of type 'S4' is not subsettable </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if (dim(.anova)[1] == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     obj$warning &lt;- list(topic = "main_anova", message = "F-Tests cannot be computed without fixed effects")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(.anova)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0b9c9f338</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> argument is of length zero </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0b8708bd8</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Sorry, `model_parameters()` failed with the following error (possible</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   class `lmerModLmerTest` not supported):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   no applicable method for 'fixef' applied to an object of class</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c('lmerModLmerTest', 'lmer')" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> RUNNER: estimating variance components</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> UseMethod("VarCorr")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0b6198270</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> no applicable method for 'VarCorr' applied to an object of class "c('lmerModLmerTest', 'lmer')" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE:  #### phase end ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> TIME: 0.198776006698608  secs</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu">simple_effects</span><span class="op">(</span><span class="va">gmod</span>,formula <span class="op">=</span><span class="op">~</span><span class="va">time</span><span class="op">:</span><span class="va">group</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: lmer   #### phase init  ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: lmer   #### phase run ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ______begin________</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> classes </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Runner Operator Scaffold R6 </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> _____end_______</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: checking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: making options</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: Estimating the model: running</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE: trying optimizer bobyqa</span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>Setting class(x) to multiple strings ("lmerModLmerTest", "lmer", ...); result will no longer be an S4 object</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> RUNNER: initial estimation done,  0.03509521484375  secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> private$.estimator[[fun]]()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0beb595b8</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> trying to get slot "optinfo" from an object (class "lmerModLmerTest") that is not an S4 object  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> `r2()` does not support models of class `lmerModLmerTest`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^r2(self$operator$model, self$operator)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bf29b988</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> object of type 'S4' is not subsettable </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^stats::anova(model, type = "3", ddf = df)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0c01b8c68</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> object of type 'S4' is not subsettable </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if (dim(.anova)[1] == 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     obj$warning &lt;- list(topic = "main_anova", message = "F-Tests cannot be computed without fixed effects")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return(.anova)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0c01c7930</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> argument is of length zero </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bd9d6900</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Sorry, `model_parameters()` failed with the following error (possible</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   class `lmerModLmerTest` not supported):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   no applicable method for 'fixef' applied to an object of class</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c('lmerModLmerTest', 'lmer')" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> RUNNER: estimating variance components</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> UseMethod("VarCorr")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bcb05dc0</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> no applicable method for 'VarCorr' applied to an object of class "c('lmerModLmerTest', 'lmer')" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> PROCEDURE: Simple Effects estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> (function (object, at, cov.reduce = mean, cov.keep = get_emm_option("cov.keep"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mult.names, mult.levs, options = get_emm_option("ref_grid"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     data, df, type, regrid, nesting, offset, sigma, counterfactuals, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     wt.counter, avg.counter = TRUE, nuisance = character(0), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     non.nuisance, wt.nuis = "equal", rg.limit = get_emm_option("rg.limit"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ...) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .foo = function(t, tr, tra, tran, transform = NULL, ...) transform</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .bar = .foo(...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(.bar)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         regrid = .bar</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("In 'ref_grid()', use 'regrid = ...' rather than 'transform = ...' ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "to avoid this message.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(df)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.null(options)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             options = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$df = df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (missing(data)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = try(recover_data(object, data = NULL, ...))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(data, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Perhaps a 'data' or 'params' argument is needed")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else if (is.null(options$delts)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = recover_data(object, data = as.data.frame(data), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.character(data)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(options$just.data)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         return(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trms = attr(data, "terms")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     coerced = .find.coerced(trms, data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sort.unique = function(x) sort(unique(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(cov.keep)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.keep = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cov.thresh = max(c(1, suppressWarnings(as.integer(cov.keep))), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.logical(cov.reduce)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!cov.reduce) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.thresh = 99</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.reduce = mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     dep.x = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     fix.cr = function(cvr) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(cvr, "formula")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (length(cvr) &lt; 3) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stop("Formulas in 'cov.reduce' must be two-sided")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             lhs = .all.vars(cvr)[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dep.x[[lhs]] &lt;&lt;- cvr</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cvr = mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (!inherits(cvr, c("function", "list"))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Invalid 'cov.reduce' argument")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cvr</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.list(cov.reduce)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.reduce = lapply(cov.reduce, fix.cr)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else cov.reduce = fix.cr(cov.reduce)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(at)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (xnm in names(at)) dep.x[[xnm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cr = function(x, nm) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.function(cov.reduce)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.reduce(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (hasName(cov.reduce, nm)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.reduce[[nm]](x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else mean(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ref.levels = matlevs = xlev = chrlev = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in attr(data, "responses")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y = data[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.matrix(y)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             matlevs[[nm]] = apply(y, 2, mean)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else ref.levels[[nm]] = mean(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in attr(data, "predictors")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x = data[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.matrix(x) &amp;&amp; ncol(x) == 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x = as.numeric(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.factor(x) &amp;&amp; !(nm %in% coerced$covariates)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xlev[[nm]] = levels(.chk.fac(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.character(x)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xlev[[nm]] = sort(unique(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!(nm %in% coerced$factors) &amp;&amp; !missing(at) &amp;&amp; (hasName(at, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nm))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = at[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.factor(x) &amp;&amp; !(nm %in% coerced$covariates)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = levels(.chk.fac(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.character(x) || is.logical(x)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = chrlev[[nm]] = sort.unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.matrix(x)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             matlevs[[nm]] = apply(x, 2, cr, nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.matrix(matlevs[[nm]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 matlevs[[nm]] = apply(matlevs[[nm]], 2, mean)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (nm %in% coerced$factors) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = sort.unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if ((length(uval &lt;- sort.unique(x)) &gt; cov.thresh) &amp;&amp; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   !(nm %in% cov.keep)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ref.levels[[nm]] = cr(as.numeric(x), nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ref.levels[[nm]] = uval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   cov.keep = c(cov.keep, nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(non.nuisance)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = setdiff(names(ref.levels), non.nuisance)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (no.nuis &lt;- (length(nuisance) == 0)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!missing(counterfactuals)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cfac = intersect(counterfactuals, names(ref.levels))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels = ref.levels[cfac]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels$.obs.no. = seq_len(nrow(data))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .check.grid(ref.levels, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = .setup.cf(ref.levels, data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .check.grid(ref.levels, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = do.call(expand.grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuis.info = .setup.nuis(nuisance, ref.levels, trms, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = nuis.info$grid</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(delts &lt;- options$delts)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         var = options$var</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         n.orig = nrow(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = grid[rep(seq_len(n.orig), length(delts)), , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$var = options$delts = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in names(matlevs)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tmp = matrix(rep(matlevs[[nm]], each = nrow(grid)), nrow = nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dimnames(tmp) = list(NULL, names(matlevs[[nm]]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[nm]] = tmp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (xnm in names(dep.x)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if ((xnm %in% c("ext", "extern", "external")) &amp;&amp; !(xnm %in% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(grid))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             fun = get(as.character(dep.x[[xnm]][[3]]), inherits = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             rslts = fun(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (nm in intersect(names(rslts), names(grid))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 grid[[nm]] = rslts[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (!all(.all.vars(dep.x[[xnm]]) %in% names(grid))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Formulas in 'cov.reduce' must predict covariates actually in the model")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xmod = lm(dep.x[[xnm]], data = data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid[[xnm]] = predict(xmod, newdata = grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[xnm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(delts)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[var]] = grid[[var]] + rep(delts, each = n.orig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(attr(data, "pass.it.on"))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         attr(object, "data") = data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     xl = xlev</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     modnm = rownames(attr(trms, "factors"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     chk = sapply(modnm, function(mn) mn %in% names(xl))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in which(!chk)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         fn = all.vars(reformulate(modnm[i]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(fn) == 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(xl)[names(xl) == fn] = modnm[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     basis = emm_basis(object, trms, xl, grid, misc = attr(data, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         "misc"), options = options, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     environment(basis$dffun) = baseenv()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(basis$bhat) != ncol(basis$X)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop("Something went wrong:\n", " Non-conformable elements in reference grid.", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             call. = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     collapse = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(counterfactuals)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = do.call(expand.grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(regrid)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             regrid = "response"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (avg.counter) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             collapse = ".obs.no."</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!no.nuis) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         basis = .basis.nuis(basis, nuis.info, wt.nuis, ref.levels, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             data, grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = basis$grid</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = ref.levels[nuis.info$nuis]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ref.levels = basis$ref.levels</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc = basis$misc</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frm = try(formula(eval(attr(data, "call")[[2]], environment(trms))), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (inherits(frm, "formula")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         lhs = if (length(frm) == 2) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else frm[-3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tran = setdiff(.all.vars(lhs, functions = TRUE), c(.all.vars(lhs), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "~", "cbind", "+", "-", "*", "/", "^", "%%", "%/%"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(tran) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (tran[1] %in% c("scale", "center", "centre", "standardize", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "standardise")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 pv = try(attr(terms(object), "predvars"), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (!inherits(pv, "try-error") &amp;&amp; !is.null(pv)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   scal = which(sapply(c(sapply(pv, as.character), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     "foo"), function(x) x[1]) == tran[1])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (length(scal) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     pv = pv[[scal[1]]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     ctr = ifelse(is.null(pv$center), 0, ifelse(pv$center, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       pv$center, 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     scl = ifelse(is.null(pv$scale), 1, ifelse(pv$scale, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       pv$scale, 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     tran = make.tran("scale", y = 0, center = ctr, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       scale = scl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (is.character(tran)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   tran = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   message("NOTE: Unable to recover scale() parameters. See '? make.tran'")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else if (tran[1] == "linkfun") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tran = as.list(environment(trms))[c("linkfun", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   "linkinv", "mu.eta", "valideta", "name")]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (tran[1] == "I") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   tran = "identity"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tran = paste(tran, collapse = ".")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 const.warn = "There are unevaluated constants in the response formula\nAuto-detection of the response transformation may be incorrect"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tst = strsplit(strsplit(as.character(lhs[2]), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   "\\(")[[1]][1], "\\*")[[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (length(tst) &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   mul = try(eval(parse(text = tst[1])), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (!inherits(mul, "try-error")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     misc$tran.mult = mul</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     tran = gsub("\\*\\.", "", tran)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else warning(const.warn)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tst = strsplit(as.character(lhs[2]), "\\(|\\)|\\+")[[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (length(tst) &gt; 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   const = try(eval(parse(text = tst[3])), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (!inherits(const, "try-error") &amp;&amp; (length(tst) == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     3)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     misc$tran.offset = const</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else warning(const.warn)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.null(misc[["tran"]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 misc$tran = tran</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else misc$tran2 = tran</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             misc$inv.lbl = "response"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     multresp = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ylevs = misc$ylevs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(ylevs)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(mult.levs)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             mult.levs = ylevs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!missing(mult.names)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             k = seq_len(min(length(ylevs), length(mult.names)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(mult.levs)[k] = mult.names[k]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(ylevs) &gt; 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ylevs = list(seq_len(prod(sapply(mult.levs, length))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         k = prod(sapply(mult.levs, length))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (k != length(ylevs[[1]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("supplied 'mult.levs' is of different length ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "than that of multivariate response")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (nm in names(mult.levs)) ref.levels[[nm]] = mult.levs[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         multresp = names(mult.levs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         MF = do.call("expand.grid", mult.levs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = merge(grid, MF)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in names(matlevs)) grid[[nm]] = matrix(rep(matlevs[[nm]], </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         each = nrow(grid)), nrow = nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     problems = if (!missing(at)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         intersect(c(multresp, coerced$factors), names(at))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(problems) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         incl.flags = rep(TRUE, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (nm in problems) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.numeric(ref.levels[[nm]])) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 dig = 3 - log10(max(abs(ref.levels[[nm]])))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 at[[nm]] = round(at[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = round(ref.levels[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 grid[[nm]] = round(grid[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             at[[nm]] = ref.levels[[nm]] = at[[nm]][at[[nm]] %in% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             rows = numeric(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (x in at[[nm]]) rows = c(rows, which(grid[[nm]] == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = grid[rows, , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid[[nm]] = factor(grid[[nm]], levels = at[[nm]])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             basis$X = basis$X[rows, , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     om = ifelse(is.null(misc$offset.mult), 1, misc$offset.mult)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     oval = 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(offset)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (offset[1] != 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             oval = offset[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (".static.offset." %in% names(grid)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid$.static.offset. = ref.levels$.static.offset. = oval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (".static.offset." %in% names(grid)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             oval = om * grid[[".static.offset."]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(attr(trms, "offset"))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (any(om != 0)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 oval = om * (oval + .get.offset(trms, grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (any(oval != 0)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[".offset."]] = oval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!hasName(data, "(weights)")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data[["(weights)"]] = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cov.keep = intersect(unique(cov.keep), names(ref.levels))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nms = union(union(union(names(xlev), names(chrlev)), coerced$factors), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.keep)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nms = intersect(nms, names(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(nms) == 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         wgt = rep(1, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         id = .my.id(data[, nms, drop = FALSE])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         uid = !duplicated(id)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         key = do.call(paste, unname(data[uid, nms, drop = FALSE]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         key = key[order(id[uid])]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tgt = do.call(paste, unname(grid[, nms, drop = FALSE]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         wgt = rep(0, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(key)) wgt[tgt == key[i]] = sum(data[["(weights)"]][id == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             i])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     grid[[".wgt."]] = wgt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     model.info = list(call = attr(data, "call"), terms = trms, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         xlev = xlev)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(mm &lt;- basis$model.matrix)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         attr(mm, "factors") = .smpFT(trms)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         model.info$model.matrix = mm</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nst = .find_nests(grid, trms, coerced$orig, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(nst) &gt; 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         model.info$nesting = nst</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$is.new.rg = TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$ylevs = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$estName = "prediction"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$estType = "prediction"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$infer = c(FALSE, FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$level = 0.95</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$adjust = "none"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$famSize = nrow(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$avgd.over)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$avgd.over = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$sigma) &amp;&amp; missing(sigma)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sigma = suppressWarnings(try(stats::sigma(object), silent = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(sigma, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sigma = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$sigma = sigma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$sigma) || (length(misc$sigma) == 0) || !is.na(misc$sigma[1])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$sigma = sigma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     post.beta = basis$post.beta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(post.beta)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         post.beta = matrix(NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     predictors = intersect(attr(data, "predictors"), names(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(counterfactuals)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         predictors = c(predictors, ".obs.no.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     simp.tbl = environment(trms)$.simplify.names.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(simp.tbl)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         names(grid) = .simplify.names(names(grid), simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         predictors = .simplify.names(predictors, simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         names(ref.levels) = .simplify.names(names(ref.levels), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(post.beta)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(post.beta) = .simplify.names(names(post.beta), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(model.info$nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             model.info$nesting = lapply(model.info$nesting, .simplify.names, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(model.info$nesting) = .simplify.names(names(model.info$nesting), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         environment(trms)$.simplify.names. = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result = new("emmGrid", model.info = model.info, roles = list(predictors = predictors, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         responses = attr(data, "responses"), multresp = multresp, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = nuisance), grid = grid, levels = ref.levels, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         matlevs = matlevs, linfct = basis$X, bhat = basis$bhat, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nbasis = basis$nbasis, V = basis$V, dffun = basis$dffun, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dfargs = basis$dfargs, misc = misc, post.beta = post.beta)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(type)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.null(options)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             options = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$predict.type = type</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@model.info$nesting = lst = .parse_nest(nesting)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(lst)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nms = union(names(lst), unlist(lst))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!all(nms %in% names(result@grid))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stop("Nonexistent variables specified in 'nesting'")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             result@misc$display = .find.nonempty.nests(result, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nms)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else if (!is.null(nst &lt;- result@model.info$nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@misc$display = .find.nonempty.nests(result)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (get_emm_option("msg.nesting")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             message("NOTE: A nesting structure was detected in the ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "fitted model:\n    ", .fmt.nest(nst))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result = .update.options(result, options, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(hook &lt;- misc$postGridHook)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.character(hook)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hook = get(hook)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@misc$postGridHook = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result = hook(result, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(regrid)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(wt.counter)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             wt.counter = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result = regrid(result, transform = regrid, sigma = sigma, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .collapse = collapse, wt.counter = wt.counter, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(collapse)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             result@misc$avgd.over = collapse</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .save.ref_grid(result)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> })(object = new("lmerModLmerTest", vcov_varpar = c(0.0450847551393491, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -0.485513550098194, -0.485513550098194, 20.9138017849741), Jac_list = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     c(220.640100832918, 3.97500715003141e-09, -1.10132633972847e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.10132482619467e-09, -7.34217055307714e-10, 2.83832778519732e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3.09584551684032e-25, 1.97805776734588e-25, 3.97500715003141e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     882.560403331673, 2.83832778519732e-25, 3.09584551684032e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.97805776734588e-25, -4.40530535891386e-09, -4.4052993047787e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -2.93686822123085e-09, -1.10132633972847e-09, 2.83832778519732e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     0, 0, 0, 4.93583723088841e-41, 5.29134417097744e-41, 3.40906046728862e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.10132482619467e-09, 3.09584551684032e-25, 0, 0, 0, 5.29134417097744e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5.57574972304866e-41, 3.62236463134203e-41, -7.34217055307714e-10, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.97805776734588e-25, 0, 0, 0, 3.40906046728862e-41, 3.62236463134203e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2.34380836621022e-41, 2.83832778519732e-25, -4.40530535891386e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.93583723088841e-41, 5.29134417097744e-41, 3.40906046728862e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     0, 0, 0, 3.09584551684032e-25, -4.4052993047787e-09, 5.29134417097744e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5.57574972304866e-41, 3.62236463134203e-41, 0, 0, 0, 1.97805776734588e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -2.93686822123085e-09, 3.40906046728862e-41, 3.62236463134203e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2.34380836621022e-41, 0, 0, 0), c(5.12215615080697, 4.43508946709194e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -5.82775425916537e-16, -4.66220340732828e-16, -3.49665255548539e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.16226505834507e-31, -9.29812046674514e-32, -6.97359035003959e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.43508946709194e-16, 20.4886246032279, -1.16226505834509e-31, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -9.29812046674514e-32, -6.97359035003959e-32, -2.33110170366615e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.86488136293131e-15, -1.39866102219416e-15, -5.82775425916537e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.16226505834509e-31, 8.75693667695025, 4.37846833845693, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.37846833847513, 1.79756725462865e-47, 1.4380538037072e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.07854035277508e-47, -4.66220340732828e-16, -9.29812046674514e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.37846833845693, 8.75693667691386, 4.37846833847513, 1.4380538037072e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.15044304296362e-47, 8.62832282220746e-48, -3.49665255548539e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -6.97359035003959e-32, 4.37846833847513, 4.37846833847513, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8.75693667695025, 1.07854035277508e-47, 8.62832282220044e-48, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     6.47124211667172e-48, -1.16226505834507e-31, -2.33110170366615e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.79756725462865e-47, 1.4380538037072e-47, 1.07854035277508e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     35.027746707801, 17.5138733538277, 17.5138733539005, -9.29812046674514e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.86488136293131e-15, 1.4380538037072e-47, 1.15044304296362e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8.62832282220044e-48, 17.5138733538277, 35.0277467076555, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     17.5138733539005, -6.97359035003959e-32, -1.39866102219416e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.07854035277508e-47, 8.62832282220746e-48, 6.47124211667172e-48, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     17.5138733539005, 17.5138733539005, 35.027746707801)), vcov_beta = c(134.563191187328, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1.1651339286056e-14, -1.53099825050199e-14, -1.2247986004016e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -9.18598950301197e-15, -3.05336445535306e-30, -2.44269156428245e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.83201867321184e-30, 1.1651339286056e-14, 538.252764749313, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.05336445535306e-30, -2.44269156428245e-30, -1.83201867321184e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -6.12399300200798e-14, -4.89919440160638e-14, -3.67439580120479e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.53099825050199e-14, -3.05336445535306e-30, 230.051819893786, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 115.025909946893, 115.025909946893, 4.72235478644528e-46, 3.77788382915623e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2.83341287186717e-46, -1.2247986004016e-14, -2.44269156428245e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 115.025909946893, 230.051819893786, 115.025909946893, 3.77788382915623e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.02230706332498e-46, 2.26673029749374e-46, -9.18598950301197e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.83201867321184e-30, 115.025909946893, 115.025909946893, 230.051819893786, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2.83341287186717e-46, 2.26673029749374e-46, 1.7000477231203e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.05336445535306e-30, -6.12399300200798e-14, 4.72235478644528e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.77788382915623e-46, 2.83341287186717e-46, 920.207279575143, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 460.103639787572, 460.103639787572, -2.44269156428245e-30, -4.89919440160638e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.77788382915623e-46, 3.02230706332498e-46, 2.26673029749374e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 460.103639787572, 920.207279575143, 460.103639787572, -1.83201867321184e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.67439580120479e-14, 2.83341287186717e-46, 2.26673029749374e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1.7000477231203e-46, 460.103639787572, 460.103639787572, 920.207279575143</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ), sigma = 52.5416200618655, resp = new("lmerResp", .xData = &lt;environment&gt;), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Gp = c(0L, 24L), call = lmerTest::lmer(formula = stats::as.formula(opts$formula), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = data, REML = reml, control = list(optimizer = "bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             restart_edge = TRUE, boundary.tol = 1e-05, calc.derivs = TRUE, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             use.last.params = FALSE, checkControl = list(check.nobs.vs.rankZ = "ignore", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.nobs.vs.nlev = "stop", check.nlev.gtreq.5 = "ignore", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.nlev.gtr.1 = "stop", check.nobs.vs.nRE = "stop", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.rankX = "message+drop.cols", check.scaleX = "warning", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.formula.LHS = "stop"), checkConv = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.conv.grad = list(action = "warning", tol = 0.002, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   relTol = NULL), check.conv.singular = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   action = "message", tol = 1e-04), check.conv.hess = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   action = "warning", tol = 1e-06)), optCtrl = list())), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frame = list(..b_b_b..XZHY = c(296, 175, 187, 192, 376, 329, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     236, 76, 309, 238, 150, 123, 222, 60, 82, 85, 150, 271, 250, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     216, 316, 291, 238, 144, 321, 364, 270, 308, 447, 402, 294, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     216, 220, 70, 95, 87, 375, 335, 334, 79, 310, 300, 253, 140, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     310, 245, 200, 120, 282, 186, 225, 134, 317, 31, 85, 120, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     362, 104, 144, 114, 338, 132, 91, 77, 263, 94, 141, 142, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     138, 38, 16, 95, 329, 62, 62, 6, 292, 139, 104, 184, 275, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     94, 135, 137, 150, 48, 20, 85, 319, 68, 67, 12, 300, 138, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     114, 174), ..b_b_b..XZ3JvdXA = c(1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ), ..b_b_b..XdGltZQ = c(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L), ..b_b_b..Xc3Viag = c(1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 11L, 11L, 11L, 11L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12L, 12L, 12L, 12L, 13L, 13L, 13L, 13L, 14L, 14L, 14L, 14L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     15L, 15L, 15L, 15L, 16L, 16L, 16L, 16L, 17L, 17L, 17L, 17L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18L, 18L, 18L, 18L, 19L, 19L, 19L, 19L, 20L, 20L, 20L, 20L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     21L, 21L, 21L, 21L, 22L, 22L, 22L, 22L, 23L, 23L, 23L, 23L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     24L, 24L, 24L, 24L)), flist = list(..b_b_b..Xc3Viag = c(1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 11L, 11L, 11L, 11L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12L, 12L, 12L, 12L, 13L, 13L, 13L, 13L, 14L, 14L, 14L, 14L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     15L, 15L, 15L, 15L, 16L, 16L, 16L, 16L, 17L, 17L, 17L, 17L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18L, 18L, 18L, 18L, 19L, 19L, 19L, 19L, 20L, 20L, 20L, 20L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     21L, 21L, 21L, 21L, 22L, 22L, 22L, 22L, 23L, 23L, 23L, 23L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     24L, 24L, 24L, 24L)), cnms = list(..b_b_b..Xc3Viag = "(Intercept)"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     lower = 0, theta = 0.959088699740652, beta = c(188.4375, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -85.9166666666665, -116.791666666667, -134.333333333333, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -164.625, -138.25, -91.5, -18.25), u = c(-15.4915268241676, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18.7367198744347, -21.6403136562519, -97.6803108130272, -7.90802306459705, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12.9978521644894, 69.1567718975256, 88.8328897601952, -92.9662409084292, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     40.4624333477991, 15.8672860194621, -10.3675377974308, 50.2321724254439, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -5.92674730759228, 29.121337635288, 11.4948153833131, 11.9047345054521, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -60.4459905520727, -25.1929460481229, 28.0965398299406, 12.1096940665216, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -57.1666375749611, -23.7582291206366, 29.5312567574269), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     devcomp = list(cmp = c(ldL2 = 37.0361007818756, ldRX2 = 16.792911466481, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     wrss = 195179.975134691, ussq = 47754.7466731463, pwrss = 242934.721807838, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     drsum = NA, REML = 1000.80478296775, dev = NA, sigmaML = 50.3047713326643, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sigmaREML = 52.5416200618655), dims = c(N = 96L, n = 96L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     p = 8L, nmp = 88L, q = 24L, nth = 1L, useSc = 1L, reTrms = 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     spFe = 0L, REML = 8L, GLMM = 0L, NLMM = 0L)), pp = new("merPredD", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .xData = &lt;environment&gt;), optinfo = list(optimizer = "bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         control = list(iprint = 0L), derivs = NULL, conv = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             opt = 0L, lme4 = NULL), feval = 15L, message = "Normal exit from bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         warnings = list(), val = 0.959088699740652)), at = list(), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nesting = NULL, infer = c(TRUE, TRUE), estName = "estimate", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     data = NULL, lmer.df = "satterthwaite", wt.nuis = "equal")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^procedure.simpleEffects(self$model, self)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bc361060</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Can't handle an object of class  “lmerModLmerTest” </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Use help("models", package = "emmeans") for information on supported models. </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> private$.estimateSimpleEffects()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0bc36e9a8</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Can't handle an object of class  “lmerModLmerTest” </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Use help("models", package = "emmeans") for information on supported models. </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> PROCEDURE: Simple Effects estimated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> (function (object, at, cov.reduce = mean, cov.keep = get_emm_option("cov.keep"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mult.names, mult.levs, options = get_emm_option("ref_grid"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     data, df, type, regrid, nesting, offset, sigma, counterfactuals, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     wt.counter, avg.counter = TRUE, nuisance = character(0), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     non.nuisance, wt.nuis = "equal", rg.limit = get_emm_option("rg.limit"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ...) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .foo = function(t, tr, tra, tran, transform = NULL, ...) transform</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .bar = .foo(...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(.bar)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         regrid = .bar</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("In 'ref_grid()', use 'regrid = ...' rather than 'transform = ...' ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "to avoid this message.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(df)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.null(options)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             options = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$df = df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (missing(data)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = try(recover_data(object, data = NULL, ...))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(data, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Perhaps a 'data' or 'params' argument is needed")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else if (is.null(options$delts)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = recover_data(object, data = as.data.frame(data), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.character(data)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(options$just.data)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         return(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     trms = attr(data, "terms")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     coerced = .find.coerced(trms, data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sort.unique = function(x) sort(unique(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(cov.keep)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.keep = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cov.thresh = max(c(1, suppressWarnings(as.integer(cov.keep))), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.logical(cov.reduce)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!cov.reduce) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.thresh = 99</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.reduce = mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     dep.x = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     fix.cr = function(cvr) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(cvr, "formula")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (length(cvr) &lt; 3) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stop("Formulas in 'cov.reduce' must be two-sided")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             lhs = .all.vars(cvr)[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dep.x[[lhs]] &lt;&lt;- cvr</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cvr = mean</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (!inherits(cvr, c("function", "list"))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Invalid 'cov.reduce' argument")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cvr</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.list(cov.reduce)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.reduce = lapply(cov.reduce, fix.cr)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else cov.reduce = fix.cr(cov.reduce)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(at)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (xnm in names(at)) dep.x[[xnm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cr = function(x, nm) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.function(cov.reduce)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.reduce(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (hasName(cov.reduce, nm)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cov.reduce[[nm]](x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else mean(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ref.levels = matlevs = xlev = chrlev = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in attr(data, "responses")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         y = data[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.matrix(y)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             matlevs[[nm]] = apply(y, 2, mean)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else ref.levels[[nm]] = mean(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in attr(data, "predictors")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         x = data[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.matrix(x) &amp;&amp; ncol(x) == 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x = as.numeric(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.factor(x) &amp;&amp; !(nm %in% coerced$covariates)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xlev[[nm]] = levels(.chk.fac(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.character(x)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xlev[[nm]] = sort(unique(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!(nm %in% coerced$factors) &amp;&amp; !missing(at) &amp;&amp; (hasName(at, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nm))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = at[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.factor(x) &amp;&amp; !(nm %in% coerced$covariates)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = levels(.chk.fac(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.character(x) || is.logical(x)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[nm]] = chrlev[[nm]] = sort.unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (is.matrix(x)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             matlevs[[nm]] = apply(x, 2, cr, nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.matrix(matlevs[[nm]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 matlevs[[nm]] = apply(matlevs[[nm]], 2, mean)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (nm %in% coerced$factors) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = sort.unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if ((length(uval &lt;- sort.unique(x)) &gt; cov.thresh) &amp;&amp; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   !(nm %in% cov.keep)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ref.levels[[nm]] = cr(as.numeric(x), nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ref.levels[[nm]] = uval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   cov.keep = c(cov.keep, nm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(non.nuisance)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = setdiff(names(ref.levels), non.nuisance)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (no.nuis &lt;- (length(nuisance) == 0)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!missing(counterfactuals)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             cfac = intersect(counterfactuals, names(ref.levels))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels = ref.levels[cfac]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels$.obs.no. = seq_len(nrow(data))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .check.grid(ref.levels, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = .setup.cf(ref.levels, data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .check.grid(ref.levels, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = do.call(expand.grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuis.info = .setup.nuis(nuisance, ref.levels, trms, rg.limit)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = nuis.info$grid</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(delts &lt;- options$delts)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         var = options$var</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         n.orig = nrow(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = grid[rep(seq_len(n.orig), length(delts)), , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$var = options$delts = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in names(matlevs)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tmp = matrix(rep(matlevs[[nm]], each = nrow(grid)), nrow = nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dimnames(tmp) = list(NULL, names(matlevs[[nm]]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[nm]] = tmp</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (xnm in names(dep.x)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if ((xnm %in% c("ext", "extern", "external")) &amp;&amp; !(xnm %in% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(grid))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             fun = get(as.character(dep.x[[xnm]][[3]]), inherits = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             rslts = fun(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (nm in intersect(names(rslts), names(grid))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 grid[[nm]] = rslts[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else if (!all(.all.vars(dep.x[[xnm]]) %in% names(grid))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("Formulas in 'cov.reduce' must predict covariates actually in the model")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             xmod = lm(dep.x[[xnm]], data = data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid[[xnm]] = predict(xmod, newdata = grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ref.levels[[xnm]] = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(delts)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[var]] = grid[[var]] + rep(delts, each = n.orig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(attr(data, "pass.it.on"))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         attr(object, "data") = data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     xl = xlev</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     modnm = rownames(attr(trms, "factors"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     chk = sapply(modnm, function(mn) mn %in% names(xl))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (i in which(!chk)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         fn = all.vars(reformulate(modnm[i]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(fn) == 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(xl)[names(xl) == fn] = modnm[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     basis = emm_basis(object, trms, xl, grid, misc = attr(data, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         "misc"), options = options, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     environment(basis$dffun) = baseenv()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(basis$bhat) != ncol(basis$X)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         stop("Something went wrong:\n", " Non-conformable elements in reference grid.", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             call. = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     collapse = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(counterfactuals)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = do.call(expand.grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(regrid)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             regrid = "response"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (avg.counter) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             collapse = ".obs.no."</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!no.nuis) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         basis = .basis.nuis(basis, nuis.info, wt.nuis, ref.levels, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             data, grid, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = basis$grid</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = ref.levels[nuis.info$nuis]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ref.levels = basis$ref.levels</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc = basis$misc</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frm = try(formula(eval(attr(data, "call")[[2]], environment(trms))), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (inherits(frm, "formula")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         lhs = if (length(frm) == 2) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         else frm[-3]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tran = setdiff(.all.vars(lhs, functions = TRUE), c(.all.vars(lhs), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             "~", "cbind", "+", "-", "*", "/", "^", "%%", "%/%"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(tran) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (tran[1] %in% c("scale", "center", "centre", "standardize", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "standardise")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 pv = try(attr(terms(object), "predvars"), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (!inherits(pv, "try-error") &amp;&amp; !is.null(pv)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   scal = which(sapply(c(sapply(pv, as.character), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     "foo"), function(x) x[1]) == tran[1])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (length(scal) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     pv = pv[[scal[1]]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     ctr = ifelse(is.null(pv$center), 0, ifelse(pv$center, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       pv$center, 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     scl = ifelse(is.null(pv$scale), 1, ifelse(pv$scale, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       pv$scale, 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     tran = make.tran("scale", y = 0, center = ctr, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                       scale = scl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (is.character(tran)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   tran = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   message("NOTE: Unable to recover scale() parameters. See '? make.tran'")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else if (tran[1] == "linkfun") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tran = as.list(environment(trms))[c("linkfun", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   "linkinv", "mu.eta", "valideta", "name")]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (tran[1] == "I") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   tran = "identity"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tran = paste(tran, collapse = ".")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 const.warn = "There are unevaluated constants in the response formula\nAuto-detection of the response transformation may be incorrect"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tst = strsplit(strsplit(as.character(lhs[2]), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   "\\(")[[1]][1], "\\*")[[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (length(tst) &gt; 1) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   mul = try(eval(parse(text = tst[1])), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (!inherits(mul, "try-error")) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     misc$tran.mult = mul</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     tran = gsub("\\*\\.", "", tran)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else warning(const.warn)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tst = strsplit(as.character(lhs[2]), "\\(|\\)|\\+")[[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 if (length(tst) &gt; 2) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   const = try(eval(parse(text = tst[3])), silent = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   if (!inherits(const, "try-error") &amp;&amp; (length(tst) == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     3)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                     misc$tran.offset = const</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   else warning(const.warn)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.null(misc[["tran"]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 misc$tran = tran</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             else misc$tran2 = tran</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             misc$inv.lbl = "response"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     multresp = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ylevs = misc$ylevs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(ylevs)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(mult.levs)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             mult.levs = ylevs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!missing(mult.names)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             k = seq_len(min(length(ylevs), length(mult.names)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(mult.levs)[k] = mult.names[k]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (length(ylevs) &gt; 1) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ylevs = list(seq_len(prod(sapply(mult.levs, length))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         k = prod(sapply(mult.levs, length))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (k != length(ylevs[[1]])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stop("supplied 'mult.levs' is of different length ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "than that of multivariate response")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (nm in names(mult.levs)) ref.levels[[nm]] = mult.levs[[nm]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         multresp = names(mult.levs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         MF = do.call("expand.grid", mult.levs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid = merge(grid, MF)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (nm in names(matlevs)) grid[[nm]] = matrix(rep(matlevs[[nm]], </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         each = nrow(grid)), nrow = nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     problems = if (!missing(at)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         intersect(c(multresp, coerced$factors), names(at))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(problems) &gt; 0) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         incl.flags = rep(TRUE, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (nm in problems) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (is.numeric(ref.levels[[nm]])) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 dig = 3 - log10(max(abs(ref.levels[[nm]])))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 at[[nm]] = round(at[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]] = round(ref.levels[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 grid[[nm]] = round(grid[[nm]], digits = dig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             at[[nm]] = ref.levels[[nm]] = at[[nm]][at[[nm]] %in% </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ref.levels[[nm]]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             rows = numeric(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             for (x in at[[nm]]) rows = c(rows, which(grid[[nm]] == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid = grid[rows, , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid[[nm]] = factor(grid[[nm]], levels = at[[nm]])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             basis$X = basis$X[rows, , drop = FALSE]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     om = ifelse(is.null(misc$offset.mult), 1, misc$offset.mult)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     oval = 0</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(offset)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (offset[1] != 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             oval = offset[1]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (".static.offset." %in% names(grid)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             grid$.static.offset. = ref.levels$.static.offset. = oval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (".static.offset." %in% names(grid)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             oval = om * grid[[".static.offset."]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(attr(trms, "offset"))) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (any(om != 0)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 oval = om * (oval + .get.offset(trms, grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (any(oval != 0)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         grid[[".offset."]] = oval</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!hasName(data, "(weights)")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data[["(weights)"]] = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     cov.keep = intersect(unique(cov.keep), names(ref.levels))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nms = union(union(union(names(xlev), names(chrlev)), coerced$factors), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         cov.keep)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nms = intersect(nms, names(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(nms) == 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         wgt = rep(1, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         id = .my.id(data[, nms, drop = FALSE])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         uid = !duplicated(id)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         key = do.call(paste, unname(data[uid, nms, drop = FALSE]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         key = key[order(id[uid])]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         tgt = do.call(paste, unname(grid[, nms, drop = FALSE]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         wgt = rep(0, nrow(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(key)) wgt[tgt == key[i]] = sum(data[["(weights)"]][id == </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             i])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     grid[[".wgt."]] = wgt</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     model.info = list(call = attr(data, "call"), terms = trms, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         xlev = xlev)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(mm &lt;- basis$model.matrix)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         attr(mm, "factors") = .smpFT(trms)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         model.info$model.matrix = mm</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nst = .find_nests(grid, trms, coerced$orig, ref.levels)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (length(nst) &gt; 0) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         model.info$nesting = nst</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$is.new.rg = TRUE</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$ylevs = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$estName = "prediction"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$estType = "prediction"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$infer = c(FALSE, FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$level = 0.95</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$adjust = "none"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     misc$famSize = nrow(grid)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$avgd.over)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$avgd.over = character(0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$sigma) &amp;&amp; missing(sigma)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         sigma = suppressWarnings(try(stats::sigma(object), silent = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (inherits(sigma, "try-error")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sigma = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$sigma = sigma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(misc$sigma) || (length(misc$sigma) == 0) || !is.na(misc$sigma[1])) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         misc$sigma = sigma</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     post.beta = basis$post.beta</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (is.null(post.beta)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         post.beta = matrix(NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     predictors = intersect(attr(data, "predictors"), names(grid))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(counterfactuals)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         predictors = c(predictors, ".obs.no.")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     simp.tbl = environment(trms)$.simplify.names.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(simp.tbl)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         names(grid) = .simplify.names(names(grid), simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         predictors = .simplify.names(predictors, simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         names(ref.levels) = .simplify.names(names(ref.levels), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(post.beta)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(post.beta) = .simplify.names(names(post.beta), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(model.info$nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             model.info$nesting = lapply(model.info$nesting, .simplify.names, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(model.info$nesting) = .simplify.names(names(model.info$nesting), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 simp.tbl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         environment(trms)$.simplify.names. = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result = new("emmGrid", model.info = model.info, roles = list(predictors = predictors, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         responses = attr(data, "responses"), multresp = multresp, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nuisance = nuisance), grid = grid, levels = ref.levels, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         matlevs = matlevs, linfct = basis$X, bhat = basis$bhat, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         nbasis = basis$nbasis, V = basis$V, dffun = basis$dffun, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         dfargs = basis$dfargs, misc = misc, post.beta = post.beta)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(type)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.null(options)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             options = list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         options$predict.type = type</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@model.info$nesting = lst = .parse_nest(nesting)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(lst)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             nms = union(names(lst), unlist(lst))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (!all(nms %in% names(result@grid))) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stop("Nonexistent variables specified in 'nesting'")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             result@misc$display = .find.nonempty.nests(result, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nms)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     else if (!is.null(nst &lt;- result@model.info$nesting)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@misc$display = .find.nonempty.nests(result)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (get_emm_option("msg.nesting")) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             message("NOTE: A nesting structure was detected in the ", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "fitted model:\n    ", .fmt.nest(nst))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result = .update.options(result, options, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!is.null(hook &lt;- misc$postGridHook)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (is.character(hook)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hook = get(hook)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result@misc$postGridHook = NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result = hook(result, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (!missing(regrid)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (missing(wt.counter)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             wt.counter = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         result = regrid(result, transform = regrid, sigma = sigma, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .collapse = collapse, wt.counter = wt.counter, ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         if (!is.null(collapse)) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             result@misc$avgd.over = collapse</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .save.ref_grid(result)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     result</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> })(object = new("lmerModLmerTest", vcov_varpar = c(0.0450847551393491, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -0.485513550098194, -0.485513550098194, 20.9138017849741), Jac_list = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     c(220.640100832918, 3.97500715003141e-09, -1.10132633972847e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.10132482619467e-09, -7.34217055307714e-10, 2.83832778519732e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3.09584551684032e-25, 1.97805776734588e-25, 3.97500715003141e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     882.560403331673, 2.83832778519732e-25, 3.09584551684032e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.97805776734588e-25, -4.40530535891386e-09, -4.4052993047787e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -2.93686822123085e-09, -1.10132633972847e-09, 2.83832778519732e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     0, 0, 0, 4.93583723088841e-41, 5.29134417097744e-41, 3.40906046728862e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.10132482619467e-09, 3.09584551684032e-25, 0, 0, 0, 5.29134417097744e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5.57574972304866e-41, 3.62236463134203e-41, -7.34217055307714e-10, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.97805776734588e-25, 0, 0, 0, 3.40906046728862e-41, 3.62236463134203e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2.34380836621022e-41, 2.83832778519732e-25, -4.40530535891386e-09, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.93583723088841e-41, 5.29134417097744e-41, 3.40906046728862e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     0, 0, 0, 3.09584551684032e-25, -4.4052993047787e-09, 5.29134417097744e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5.57574972304866e-41, 3.62236463134203e-41, 0, 0, 0, 1.97805776734588e-25, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -2.93686822123085e-09, 3.40906046728862e-41, 3.62236463134203e-41, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2.34380836621022e-41, 0, 0, 0), c(5.12215615080697, 4.43508946709194e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -5.82775425916537e-16, -4.66220340732828e-16, -3.49665255548539e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.16226505834507e-31, -9.29812046674514e-32, -6.97359035003959e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.43508946709194e-16, 20.4886246032279, -1.16226505834509e-31, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -9.29812046674514e-32, -6.97359035003959e-32, -2.33110170366615e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.86488136293131e-15, -1.39866102219416e-15, -5.82775425916537e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.16226505834509e-31, 8.75693667695025, 4.37846833845693, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.37846833847513, 1.79756725462865e-47, 1.4380538037072e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.07854035277508e-47, -4.66220340732828e-16, -9.29812046674514e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4.37846833845693, 8.75693667691386, 4.37846833847513, 1.4380538037072e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.15044304296362e-47, 8.62832282220746e-48, -3.49665255548539e-16, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -6.97359035003959e-32, 4.37846833847513, 4.37846833847513, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8.75693667695025, 1.07854035277508e-47, 8.62832282220044e-48, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     6.47124211667172e-48, -1.16226505834507e-31, -2.33110170366615e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.79756725462865e-47, 1.4380538037072e-47, 1.07854035277508e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     35.027746707801, 17.5138733538277, 17.5138733539005, -9.29812046674514e-32, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -1.86488136293131e-15, 1.4380538037072e-47, 1.15044304296362e-47, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8.62832282220044e-48, 17.5138733538277, 35.0277467076555, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     17.5138733539005, -6.97359035003959e-32, -1.39866102219416e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1.07854035277508e-47, 8.62832282220746e-48, 6.47124211667172e-48, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     17.5138733539005, 17.5138733539005, 35.027746707801)), vcov_beta = c(134.563191187328, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1.1651339286056e-14, -1.53099825050199e-14, -1.2247986004016e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -9.18598950301197e-15, -3.05336445535306e-30, -2.44269156428245e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.83201867321184e-30, 1.1651339286056e-14, 538.252764749313, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.05336445535306e-30, -2.44269156428245e-30, -1.83201867321184e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -6.12399300200798e-14, -4.89919440160638e-14, -3.67439580120479e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.53099825050199e-14, -3.05336445535306e-30, 230.051819893786, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 115.025909946893, 115.025909946893, 4.72235478644528e-46, 3.77788382915623e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2.83341287186717e-46, -1.2247986004016e-14, -2.44269156428245e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 115.025909946893, 230.051819893786, 115.025909946893, 3.77788382915623e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.02230706332498e-46, 2.26673029749374e-46, -9.18598950301197e-15, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -1.83201867321184e-30, 115.025909946893, 115.025909946893, 230.051819893786, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 2.83341287186717e-46, 2.26673029749374e-46, 1.7000477231203e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.05336445535306e-30, -6.12399300200798e-14, 4.72235478644528e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.77788382915623e-46, 2.83341287186717e-46, 920.207279575143, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 460.103639787572, 460.103639787572, -2.44269156428245e-30, -4.89919440160638e-14, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 3.77788382915623e-46, 3.02230706332498e-46, 2.26673029749374e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 460.103639787572, 920.207279575143, 460.103639787572, -1.83201867321184e-30, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> -3.67439580120479e-14, 2.83341287186717e-46, 2.26673029749374e-46, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 1.7000477231203e-46, 460.103639787572, 460.103639787572, 920.207279575143</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ), sigma = 52.5416200618655, resp = new("lmerResp", .xData = &lt;environment&gt;), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     Gp = c(0L, 24L), call = lmerTest::lmer(formula = stats::as.formula(opts$formula), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         data = data, REML = reml, control = list(optimizer = "bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             restart_edge = TRUE, boundary.tol = 1e-05, calc.derivs = TRUE, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             use.last.params = FALSE, checkControl = list(check.nobs.vs.rankZ = "ignore", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.nobs.vs.nlev = "stop", check.nlev.gtreq.5 = "ignore", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.nlev.gtr.1 = "stop", check.nobs.vs.nRE = "stop", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.rankX = "message+drop.cols", check.scaleX = "warning", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.formula.LHS = "stop"), checkConv = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 check.conv.grad = list(action = "warning", tol = 0.002, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   relTol = NULL), check.conv.singular = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   action = "message", tol = 1e-04), check.conv.hess = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   action = "warning", tol = 1e-06)), optCtrl = list())), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     frame = list(..b_b_b..XZHY = c(296, 175, 187, 192, 376, 329, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     236, 76, 309, 238, 150, 123, 222, 60, 82, 85, 150, 271, 250, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     216, 316, 291, 238, 144, 321, 364, 270, 308, 447, 402, 294, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     216, 220, 70, 95, 87, 375, 335, 334, 79, 310, 300, 253, 140, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     310, 245, 200, 120, 282, 186, 225, 134, 317, 31, 85, 120, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     362, 104, 144, 114, 338, 132, 91, 77, 263, 94, 141, 142, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     138, 38, 16, 95, 329, 62, 62, 6, 292, 139, 104, 184, 275, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     94, 135, 137, 150, 48, 20, 85, 319, 68, 67, 12, 300, 138, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     114, 174), ..b_b_b..XZ3JvdXA = c(1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ), ..b_b_b..XdGltZQ = c(1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L, 1L, 2L, 3L, 4L), ..b_b_b..Xc3Viag = c(1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 11L, 11L, 11L, 11L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12L, 12L, 12L, 12L, 13L, 13L, 13L, 13L, 14L, 14L, 14L, 14L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     15L, 15L, 15L, 15L, 16L, 16L, 16L, 16L, 17L, 17L, 17L, 17L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18L, 18L, 18L, 18L, 19L, 19L, 19L, 19L, 20L, 20L, 20L, 20L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     21L, 21L, 21L, 21L, 22L, 22L, 22L, 22L, 23L, 23L, 23L, 23L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     24L, 24L, 24L, 24L)), flist = list(..b_b_b..Xc3Viag = c(1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 7L, 7L, 7L, 7L, 8L, 8L, 8L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 11L, 11L, 11L, 11L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12L, 12L, 12L, 12L, 13L, 13L, 13L, 13L, 14L, 14L, 14L, 14L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     15L, 15L, 15L, 15L, 16L, 16L, 16L, 16L, 17L, 17L, 17L, 17L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18L, 18L, 18L, 18L, 19L, 19L, 19L, 19L, 20L, 20L, 20L, 20L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     21L, 21L, 21L, 21L, 22L, 22L, 22L, 22L, 23L, 23L, 23L, 23L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     24L, 24L, 24L, 24L)), cnms = list(..b_b_b..Xc3Viag = "(Intercept)"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     lower = 0, theta = 0.959088699740652, beta = c(188.4375, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -85.9166666666665, -116.791666666667, -134.333333333333, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -164.625, -138.25, -91.5, -18.25), u = c(-15.4915268241676, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     18.7367198744347, -21.6403136562519, -97.6803108130272, -7.90802306459705, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     12.9978521644894, 69.1567718975256, 88.8328897601952, -92.9662409084292, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     40.4624333477991, 15.8672860194621, -10.3675377974308, 50.2321724254439, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -5.92674730759228, 29.121337635288, 11.4948153833131, 11.9047345054521, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -60.4459905520727, -25.1929460481229, 28.0965398299406, 12.1096940665216, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     -57.1666375749611, -23.7582291206366, 29.5312567574269), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     devcomp = list(cmp = c(ldL2 = 37.0361007818756, ldRX2 = 16.792911466481, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     wrss = 195179.975134691, ussq = 47754.7466731463, pwrss = 242934.721807838, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     drsum = NA, REML = 1000.80478296775, dev = NA, sigmaML = 50.3047713326643, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sigmaREML = 52.5416200618655), dims = c(N = 96L, n = 96L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     p = 8L, nmp = 88L, q = 24L, nth = 1L, useSc = 1L, reTrms = 1L, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     spFe = 0L, REML = 8L, GLMM = 0L, NLMM = 0L)), pp = new("merPredD", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         .xData = &lt;environment&gt;), optinfo = list(optimizer = "bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         control = list(iprint = 0L), derivs = NULL, conv = list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             opt = 0L, lme4 = NULL), feval = 15L, message = "Normal exit from bobyqa", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         warnings = list(), val = 0.959088699740652)), at = list(), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     nesting = NULL, infer = c(TRUE, TRUE), estName = "estimate", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     data = NULL, lmer.df = "satterthwaite", wt.nuis = "equal")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^procedure.simpleEffects(self$model, self)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0baadce90</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Can't handle an object of class  “lmerModLmerTest” </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Use help("models", package = "emmeans") for information on supported models. </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> SOURCE: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> private$.estimateSimpleEffects()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> CALLER: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="font-weight: bold;">&lt;quosure&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> expr: <span style="color: #0000BB;">^private$.estimator[[fun]]()</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> env:  <span style="color: #0000BB;">0x5dd0baae7ed0</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ERROR: </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Can't handle an object of class  “lmerModLmerTest” </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Use help("models", package = "emmeans") for information on supported models. </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> MODULE:  #### phase end ####</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> TIME: 0.273353099822998  secs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  SIMPLE EFFECTS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ANOVA for Simple Effects  of time               </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group    F    Num df    Den df    p           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .    .         .         .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .    .         .         .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  Parameter Estimates for simple effects of time                                  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group    Effect    Estimate    SE    Lower    Upper    df    t    p           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             .         .           .     .        .        .     .    .           </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ─────────────────────────────────────────────────────────────────────────────── </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Marcello Gallucci.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

